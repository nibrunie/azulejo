import argparse
import cv2
import random
import math
import time
import re

import numpy as np

import os
from os.path import isfile, join


def parse_metric(metric_label):
    """ convert str to metric function """
    return {
        "average": average_metric,
        "palette": palette_metric,
        "sub": sub_metric,
    }[metric_label]

def parse_int_tuple(tuple_str):
    """ convert str to integer tuple """
    result = tuple(int(v) for v in tuple_str.split(","))
    assert len(result) == 2
    return result

def average_metric(img):
    """ return the value of a metric on an image """
    avg = img.mean(axis=0).mean(axis=0)
    return avg

def palette_metric(img):
    # determine a dominant "color" by clustering colors in 5 palettes
    n_colors = 5
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)
    flags = cv2.KMEANS_RANDOM_CENTERS
    flatten_img = np.float32(img.view().reshape(-1, 3))

    _, labels, palette = cv2.kmeans(flatten_img, n_colors, criteria, 10, flags)
    _, counts = np.unique(labels, return_counts=True)
    dominant = palette[np.argmax(counts)]
    return dominant

def sub_metric(img):
    return cv2.resize(cv2.cvtColor(img, (cv2.COLOR_BGR2GRAY)), (4, 4)).reshape(1, -1)



def build_image_library(original_library, metric_fct, dump_dir, tile_angles, verbose=False, sampling=None):
    """ build a library of thumbnails 
        @param original_library directory containing source images
        @param metric_fct
        @param dump_dir directory containing generated thumbnails
        @param angles
        @sampling (None: disabled) select a sub-sample of the library
        
        If a thumbnail has already been generated by a previous run, it will not be generated twice
        """
    if not os.path.isdir(dump_dir):
        print("creating directory {}".format(dump_dir))
        os.mkdir(dump_dir)
    image_library = []
    pixel_library = [f for f in os.listdir(dump_dir) if isfile(join(dump_dir, f))]
    for dirpath, dirnames, filenames in os.walk(original_library):
        for _f in filenames:
            filename = os.path.join(original_library, dirpath, _f)
            if verbose: print("processing {}".format(filename))
            base = os.path.basename(filename)
            prefix, extension = os.path.splitext(base)
            extension = extension.lower()
            thumb_filename = prefix + "_{}x{}".format(THUMB_W, THUMB_H) + extension
            if extension in [".png", ".jpg"]:
                # only png and jpg image are processed
                if thumb_filename in pixel_library:
                    # check if a file with name matching thumbnail filename already exists
                    if verbose: print("pixel found in temporary library")
                    thumb = cv2.imread(join(dump_dir, thumb_filename))
                else:
                    if verbose: print("pixel NOT found in temporary library")
                    try:
                        picture = cv2.imread(filename)
                        thumb = cv2.resize(picture, (THUMB_W, THUMB_H))
                        # saving thumbnail
                        cv2.imwrite(os.path.join(dump_dir, thumb_filename), thumb)
                    except:
                        print(f"[error] unable to process {filename}")
                for rot_angle in tile_angles:
                    M = cv2.getRotationMatrix2D((THUMB_W/2,THUMB_H/2),rot_angle,1)
                    new_tile = cv2.warpAffine(thumb,M,(THUMB_W,THUMB_H))
                    metric = metric_fct(new_tile)
                    image_library.append((metric, new_tile))
    print("library, containing {} image(s), has been generated".format(len(image_library)))
    if sampling:
        return random.choices(image_library, k=sampling)
    else:
        return image_library


def load_pixel_library(pixel_dir, metric_fct, tile_angles, verbose=False, sampling=None):
    """ load a library of thumbnails 
        @param pixel_dir directory containing generated thumbnails
        @param metric_fct
        @param angles
        @sampling (None: disabled) select a sub-sample of the library
        
        If a thumbnail has already been generated by a previous run, it will not be generated twice
        """
    if not os.path.isdir(pixel_dir):
        raise Exception(f"{pixel_dir} does not exist")
    image_library = []
    pixel_library = [f for f in os.listdir(pixel_dir) if isfile(join(pixel_dir, f))]
    for thumb_filename in pixel_library:
        thumbMatch = re.match(".*_(?P<w>\d+)x(?P<h>\d+).(jpg|JPG|PNG|png)", thumb_filename)
        if thumbMatch:
            w = int(thumbMatch.group("w"))
            h = int(thumbMatch.group("h"))
            if w == THUMB_W and h == THUMB_H:
                if verbose: print(f"pixel {thumb_filename} with matching dimensions found in temporary library")
                thumb = cv2.imread(join(pixel_dir, thumb_filename))
                for rot_angle in tile_angles:
                    M = cv2.getRotationMatrix2D((THUMB_W/2,THUMB_H/2),rot_angle,1)
                    new_tile = cv2.warpAffine(thumb,M,(THUMB_W,THUMB_H))
                    metric = metric_fct(new_tile)
                    image_library.append((metric, new_tile))
    print("library, containing {} image(s), has been generated".format(len(image_library)))
    if sampling:
        return random.choices(image_library, k=sampling)
    else:
        return image_library


def buildMosaicTiles(metric_fct, image_library, random_size=6):
    """ Building a mozaic approximating the source image """
    # iterating over 2D tiles of the source image. each tile is THUMB_W x THUMB_H
    #   - for each tile select the closest library thumbnail
    #   - build the destination image by replacing each source tile by the selected thumbnail
    #
    # Two metrics are used:
    # - the first metric, dist, is used to select the <random_size> closest thumbnail to the local tile

    # metric linearization

    # determing for the 3D metric (color) a max and a min vector
    max_0 = max(m[0] for (m, t) in  image_library)
    max_1 = max(m[1] for (m, t) in  image_library)
    max_2 = max(m[2] for (m, t) in  image_library)
    min_0 = min(m[0] for (m, t) in  image_library)
    min_1 = min(m[1] for (m, t) in  image_library)
    min_2 = min(m[2] for (m, t) in  image_library)

    min_v = np.array([min_0, min_1, min_2])
    max_v = np.array([max_0, max_1, max_2])
    delta_v = max_v - min_v

    def tileLinearizedMetric(metric):
        # saturating the current vector metric between min and max value
        saturatedMetric = np.maximum(np.minimum(metric, max_v), min_v)
        # evaluating a scalar metric by normalizaing each component and generating a 3-digit number
        scalarMetric = np.dot((saturatedMetric - min_v) / delta_v, np.array([1, 2, 4]))
        return scalarMetric

    linImgLib = sorted(image_library, key=lambda metric_tile: tileLinearizedMetric(metric_tile[0]))
    linImgMetric = [tileLinearizedMetric(metric) for (metric, tile) in linImgLib]
    imgMaxIdx = len(linImgLib)
    def getClosestTile(metric):
        # using a median pivot to locate in logarithm time, <random_size> closest
        # neighbours
        scalarMetric = tileLinearizedMetric(metric)
        idx = imgMaxIdx // 2
        idxSup = imgMaxIdx - 1
        idxInf = 0
        while idxSup - idxInf > random_size:
            if linImgMetric[idx] < scalarMetric:
                idxInf = idx 
            else:
                idxSup = idx
            idx = idxInf + (idxSup - idxInf) // 2
        idx = max(min(idx, imgMaxIdx - random_size // 2), random_size // 2)
        return max(0, min(random.randrange(idx - random_size // 2, idx + random_size // 2), imgMaxIdx-1))

    # retrieving the closest tile from each source tile
    tiles = {}
    for tile_y in range(source_heigth // THUMB_H):
        for tile_x in range(source_width // THUMB_W):
            x = tile_x * THUMB_W
            y = tile_y * THUMB_H
            local_thumb = source[y:(y+THUMB_H), x:(x+THUMB_W)]
            src_average = metric_fct(local_thumb)
            src_sub = sub_metric(local_thumb)
            def dist(lib_img):
                delta = src_average - lib_img[0]
                value = np.dot(delta, delta.transpose())
                # the actual distance should be math.sqrt(value) but since
                # we compare 2 distances, we can save the square root evaluation
                return value
            def sub_dist(lib_img):
                delta = src_sub - sub_metric(lib_img[1])
                value = np.dot(delta, delta.transpose())
                return math.sqrt(value)
            if False:
                closest_list = sorted(image_library, key=dist)[:random_size]
                closest = random.choice(closest_list)[1]
                #closest = sorted(closest_list, key=sub_dist)[random.randrange(random_size)][1]
                #closest = closest_list[random.randrange(random_size)][1]
            else:
                closestIdx = getClosestTile(src_average)
                closest = linImgLib[closestIdx][1]
            tiles[(tile_x, tile_y)] = closest
    return tiles

def generateSingleImage(tiles, stripes=None):
    # generate mosaic image
    dest = np.zeros((source_heigth, source_width, 3), np.uint8)
    NUM_TILES_X = source_width // THUMB_W
    for tile_y in range(source_heigth // THUMB_H):
        y = tile_y * THUMB_H
        for tile_x in range(NUM_TILES_X):
            x = tile_x * THUMB_W
            closest = tiles[(tile_x, tile_y)]
            local_thumb = source[y:(y+THUMB_H), x:(x+THUMB_W)]
            alphaThumb = 0.4
            alphaSource = 1 - alphaThumb
            dest[y:(y+THUMB_H), x:(x+THUMB_W)] = closest * alphaThumb + local_thumb * alphaSource
    # stripes
    addStripe = not stripes is None
    if addStripe:
        stripeWidth, nextStripe = stripes
        for stripe in range(0, source_width, stripeWidth):
            # p = stripe / source_width / 2
            # black = random.random() > (1 - p) 
            index = stripe // stripeWidth
            black = index == nextStripe
            if black:
                dest[0:source_heigth,stripe:stripe+stripeWidth] = 0
                nextStripe = index + max(int(50 * (1.0 - (index / (source_width // stripeWidth))**2)), 2)
    
    return dest

def generateVideo(tiles, source_width, source_height, w=1024, h=768, NUM_FRAMES=250, EXTRA_FRAMES=250, videoFileName="mosaic-video.avi", FPS=25):
    # recombing closest and source tiles with complementary alpha values
    frameSize = (w, h)
    out = cv2.VideoWriter(videoFileName, cv2.VideoWriter_fourcc(*'DIVX'), FPS, frameSize)

    for i in range(NUM_FRAMES):
        # generating empty image for destination
        print(f"generating frame {i}")
        frame = np.zeros((source_heigth, source_width, 3), np.uint8)
        mosaicSplitX = 1 - i / NUM_FRAMES
        NUM_TILES_X = source_width // THUMB_W
        for tile_y in range(source_heigth // THUMB_H):
            y = tile_y * THUMB_H
            for tile_x in range(NUM_TILES_X):
                x = tile_x * THUMB_W
                closest = tiles[(tile_x, tile_y)]
                local_thumb = source[y:(y+THUMB_H), x:(x+THUMB_W)]
                deltaX = tile_x - mosaicSplitX * NUM_TILES_X
                alphaThumb = 0 if deltaX < 0 else (deltaX / ((1 - mosaicSplitX) * NUM_TILES_X))
                alphaSource = 1 - alphaThumb
                frame[y:(y+THUMB_H), x:(x+THUMB_W)] = closest * alphaThumb + local_thumb * alphaSource
        img = cv2.resize(frame, frameSize)
        out.write(img)

    for j in range(EXTRA_FRAMES):
        out.write(img)

    out.release()


class PerfMetric:
    def __init__(self, label):
        self.label = label
        self.startTS = None
        self.stopTS  = None

    def start(self):
        self.startTS = time.perf_counter()
    def stop(self):
        self.stopTS = time.perf_counter()

    def summary(self):
        return f"{self.label:20} executed in {self.stopTS - self.startTS:.3} second(s)"

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='build the mosaic version of an image')
    parser.add_argument('--library', default=None, type=str, help='path to pixel library')
    parser.add_argument("--pixel-dir", default="./.mosaic_libs/", type=str, help="directory to save pixel thumbnails")
    parser.add_argument('--source', type=str, help='path to source image')
    parser.add_argument('--dest', default="mosaic.png", type=str, help='path to destination image')
    parser.add_argument('--metric', default=average_metric, type=parse_metric, help='set metric to determine closest thumbnail')
    parser.add_argument("--thumb-size", default=(32, 32), type=parse_int_tuple, help='set thumbnail size')
    parser.add_argument("--random-size", default=6, type=int, help='size of the closest pixel set to chose from')
    parser.add_argument("--source-coeff", default=0.25, type=float, help='coefficient of source image in final output blending')
    parser.add_argument("--mosaic-coeff", default=0.75, type=float, help='coefficient of generated mosaic image in final output blending')
    parser.add_argument("--tile-angles", default=[0], type=(lambda s: [float(v) for v in s.split(",")]), help="list of possible angles for the tiles")
    parser.add_argument("--verbose", default=False, const=True, action="store_const", help="display more verbose info messages")
    parser.add_argument("--sampling", default=None, type=int, action="store", help="select a sample of the library (random)")
    parser.add_argument("--stripes", default=None, type=(lambda s: map(int, s.split(','))), action="store", help="optionally add stripes, option values is (width, step)")

    subParsers = parser.add_subparsers()
    def cmdLineSingleImgGen(args, tiles):
        dest = generateSingleImage(tiles, args.stripes) 
        cv2.imwrite(args.dest, dest)
    def cmdLineVideoGen(args, tiles):
        generateVideo(tiles, source_width, source_heigth)
    videoCmdParser = subParsers.add_parser('video', help='generate video output')
    videoCmdParser.set_defaults(func=cmdLineVideoGen)
    imageCmdParser = subParsers.add_parser('image', help="generate image output")
    imageCmdParser.set_defaults(func=cmdLineSingleImgGen)

    args = parser.parse_args()

    THUMB_W, THUMB_H = args.thumb_size

    print("reading source image")
    source = cv2.imread(args.source)
    source_width = source.shape[1]
    source_heigth = source.shape[0]

    print("building destination image of size {} x {}".format(source_width, source_heigth))
    print("loading image from library")

    genLibMetric    = PerfMetric("thumbnail generation")
    genTilesMetric  = PerfMetric("tiles     generation")
    genMosaicMetric = PerfMetric("mosaic    generation")

    genLibMetric.start()
    if args.library:
        image_library = build_image_library(args.library, args.metric, args.pixel_dir, args.tile_angles, args.verbose, args.sampling)
    else:
        image_library = load_pixel_library(args.pixel_dir, args.metric, args.tile_angles, args.verbose, args.sampling)
    genLibMetric.stop()


    genTilesMetric.start()
    tiles = buildMosaicTiles(args.metric, image_library, args.random_size)
    genTilesMetric.stop()


    genMosaicMetric.start()
    args.func(args, tiles)
    genMosaicMetric.stop()


    for metric in [genLibMetric, genTilesMetric, genMosaicMetric]:
        print(metric.summary())






